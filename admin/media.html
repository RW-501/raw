<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event & Photo Management</title>
    <!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">


<link rel="stylesheet" href="../css/admin.css">

<style>

#Manage_Events {
    width: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    

}

#eventsContainer {
    width: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
   
}

.mainEventPanel {
    display: grid;
    width: 50%;
    overflow: hidden;

}
.eventPanel {
    display: flex;
    width: 100%;
    overflow: hidden;
    flex-wrap: wrap;
}



.event_details_cover {
    display: grid;
    gap: 1rem;
}
  
.manageEventsArea {
    width: 100%;    
}

.batch-buttons {
    display: flex;
    width: 100%;
    overflow: hidden;
    flex-wrap: wrap;
}
 
 

.event_photos_list {
    display: flex;
    width: 100%;
    overflow: hidden;
    flex-wrap: wrap;
}

.media-item {
    width: 50%;
    display: flex;
    overflow: hidden;
    flex-wrap: wrap;
    justify-content: space-evenly;

    gap: .5rem;
    padding: 15px;
    border-radius: 8px;
    margin:  auto;
    width: 90%;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);

}

.media-header {
    display: grid;
    width: 100%;

}

.media-item-img-details {
    display: grid; 
}




#mainGallerySection {
    display: grid; 
    width: 100%;
    overflow: hidden;

}

#galleryContainer {
    display: grid; 
    width: 100%;
    overflow: hidden;
}
.gallery-item {
    gap: 1.5rem;
    display: flex;
    width: 100%;
    overflow: hidden;
    flex-wrap: wrap;
    justify-content: space-between;

    gap: .5rem;
    padding: 15px;
    border-radius: 8px;
    margin: auto;
    width: 90%;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);

}
.media-container {
    display: grid;
 width: 100%
}
.media-header {
 display: grid;
 width: 100%;

}
.gallery-details {
    display: grid;
    width: 100%;
}

.flex {
    display: flex;
}

.media-thumbnail-cover {
    width: 200px !important;
}


.media-thumbnail {
    width: 200px !important;
}


.appearOnContainer {
    width: 100%;
}


</style>
  



</head>
<body>


<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-dark">
    <a class="navbar-brand" href="https://shutterworx.co/">ShutterWorx </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ml-auto">
            <li class="nav-item">
                <a class="nav-link" href="../">Your Site</a>
            </li>

            <li class="nav-item">
                <a class="nav-link" href="../admin/">Home</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/media">Media</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/contact">Contact</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/design">Design</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/analytics">Analytics</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/transactions">Transactions</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/settings">Settings</a>
            </li>
        </ul>
    </div>
</nav>


<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
      <li class="breadcrumb-item"><a href="../admin/">Home</a></li>
      <li class="breadcrumb-item active" aria-current="page">Media</li>
    </ol>
  </nav>
  


  <main id="main-content">


        <h2 class="text-center mb-4">Event & Photo Management</h2>
    
        <!-- Admin Messages Section -->
        <section>
            <div id="admin-messages" class="admin-messages-container">
                <p id="message-text" class="fade-in"></p>
                <div id="message-actions" class="message-actions"></div>
            </div>
        </section>
    
<!-- Add to Gallery Button 
<button onclick="openAddToGalleryModal()">Add to Gallery</button>
-->

<!-- Toggle Bar -->
<div class="mediaTabs">
   <button class="tabButton" onclick="showTabContent('Add_Event')">Add Event</button>
 <!--     <button class="tabButton" onclick="showTabContent('Add_Media')">Add Media</button> -->
    <button class="tabButton" onclick="showTabContent('Manage_Events')">Manage Events</button>
    <button class="tabButton" onclick="showTabContent('Manage_Gallery')">Manage Gallery</button>
</div>


<div id="Add_Event" class="media_tabs">

        <!-- Event Upload Form -->
        <div class="card mb-4 shadow-lg">
            <div class="card-body">
                <h5 id="Add_Event_Label" class="card-title">Add New Event</h5>
                <form id="eventForm">
                    <div class="mb-3">
                        <label for="eventTitle" class="form-label">Event Title</label>
                        <input type="text" class="form-control" id="eventTitle" required>
                    </div>
                    <div class="mb-3">
                        <label for="eventDescription" class="form-label">Description</label>
                        <textarea class="form-control" id="eventDescription" rows="4"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="location" class="form-label">Event Location</label>
                        <input type="text" class="form-control" id="location" >
                    </div>


                    <div class="mb-3">
                        <label for="eventDate" class="form-label">Event Date</label>
                        <input type="date" class="form-control" id="eventDate" required>
                    </div>
                    <div class="mb-3" id="eventCoverArea">
                        <label for="eventCover" class="form-label">Cover Photo</label>
                                        <!-- Cover Photo Area -->
                                        <div class="center">
                                            <img id="eventCoverPreview" src="" alt="Image Preview" />
                </div>
                        <input hidden type="file" class="form-control" id="eventCover" accept="image/*" required>
                    </div>
                    <div class="mb-3">
                        <label for="accessCode" class="form-label">Access Code (if private)</label>
                        <input type="text" class="form-control" id="accessCode" placeholder="Optional">
                    </div> 
                    <div class="controls">
                    <button id="uploadEventBTN" type="button" class="btn btn-primary" >Upload Event</button>
                    <button id="saveEvent" type="button" class="btn btn-primary" >Save Event</button>
                    <button id="addMedia" type="button" class="btn btn-primary" onclick="addMediaToEvent()">Add Media</button>
                </div>

                </form>
            </div>
        </div>


    </div>
    <div id="Add_Media" class="media_tabs">
        <div class="card mb-4 shadow-lg">
            <div class="card-body">
                <h5 class="card-title">Upload Photos for Events</h5>
                                <!-- Preview Area -->
                                <div class="mt-4">
                                    <h5>Preview:</h5>
                                    <div class="center">
                                    <canvas id="watermarkPreview" style="max-width: 100%; height: auto;"></canvas>
                            </div>
                                    <button id="photoUploadBTN" type="button" class="btn btn-primary mt-3">Add Image for Watermark Preview</button>

                <input hidden type="file" id="photoUpload" class="form-control" multiple accept="image/*">
            </div>
<div id="watermarkTabs" class="grid">

           
            
            <div class="dropdown">    <label for="tabSelector" class="form-label">Select Tab</label>
                <select class="form-select" id="tabSelector" onchange="showTab(this.value)">
                    <option value="watermarkTextDiv" selected>Watermark Text</option>
                    <option value="fontColorDiv">Choose Text Color</option>
                    <option value="fontFamilyDiv">Watermark Font</option>
                    <option value="watermarkPositionDiv">Watermark Position</option>
                    <option value="textGapDiv">Text Gap</option>
                    <option value="fontSizeDiv">Font Size</option>
                    <option value="watermarkOpacityDiv">Watermark Opacity</option>
                    <option value="logoOverlayDiv">Logo Overlay</option>
                    <option value="logoScaleDiv">Logo Scale</option>
                </select>
            </div>

            <div class="watermarkTabs" id="watermarkTextDiv">
                <label for="watermarkText" class="form-label">Watermark Text</label>
                <input type="text" class="form-control" id="watermarkText" placeholder="Enter watermark text">
            </div>
            
            <div class="watermarkTabs" id="fontColorDiv">
                <label for="fontColor">Choose Text Color:</label>
                <input type="color" id="fontColor" name="fontColor" value="#000000">
            </div>
            <div class="watermarkTabs" id="fontFamilyDiv">
                <label for="fontFamily">Font Family:</label>
                <select id="fontFamily">
                    <option value="Arial">Arial</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Trebuchet MS">Trebuchet MS</option>
                    <option value="Lucida Console">Lucida Console</option>
                    <option value="Tahoma">Tahoma</option>
                    <option value="Impact">Impact</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Palatino Linotype">Palatino Linotype</option>
                    <option value="Garamond">Garamond</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Arial Black">Arial Black</option>
                    <option value="Courier">Courier</option>
                    <option value="Futura">Futura</option>
                    <option value="Geneva">Geneva</option>
                    <option value="Consolas">Consolas</option>
                    <option value="Lucida Sans">Lucida Sans</option>
                    <option value="Microsoft Sans Serif">Microsoft Sans Serif</option>
                </select>
            </div>
            
            <div class="watermarkTabs" id="watermarkPositionDiv">
                <label for="watermarkPosition" class="form-label">Watermark Position</label>
                <select id="watermarkPosition">
                    <option value="center">Center</option>
                    <option value="diagonal">Diagonal</option>
                    <option value="horizontal">Horizontal</option>
                </select>
            </div>
            
            <div class="watermarkTabs" id="textGapDiv">
                <label for="textGap">Text Gap:</label>
                <input type="range" id="textGap" min="10" max="200" step="5" value="50">
            </div>
            
            <div class="watermarkTabs" id="fontSizeDiv">
                <label for="fontSize">Font Size:</label>
                <input type="number" id="fontSize" step="10" value="200" min="10" max="500">
            </div>
            
            <div class="watermarkTabs" id="watermarkOpacityDiv">
                <label for="watermarkOpacity" class="form-label">Watermark Opacity</label>
                <input type="range" class="form-control" id="watermarkOpacity" min="0" max="1" step="0.1" value="0.5">
            </div>
            
            <div class="watermarkTabs" id="logoOverlayDiv">
                <label for="logoOverlay" class="form-label">Logo Overlay (Optional)</label>
                <div class="center">
                    <img id="logoOverlayPreview" src="" alt="Logo Preview" />
                </div>
                <input hidden type="file" class="form-control" id="logoOverlay" accept="image/*">
            </div>
            
            <div class="watermarkTabs" id="logoScaleDiv">
                <label for="logoScale" class="form-label">Logo Scale (Resize)</label>
                <input type="range" class="form-control" id="logoScale" min="0.1" max="1" step="0.1" value="0.5">
            </div>
        </div>
        <div class="mt-3">
        <button onclick="clearWatermarkInputs()">Clear Inputs</button>
</div>
                <div class="mt-3">
                    <label for="photoPrice" class="form-label">Photo Price</label>
                    <input type="number" class="form-control" id="photoPrice" placeholder="Set price for this photo (optional)">
                </div>
                <div class="mt-3">
                    <label for="photoPublic" class="form-label">Make Photo Public</label>
                    <input type="checkbox" id="photoPublic" class="form-check-input">
                </div>
                <div class="mt-3">
                    <label for="collectionPrice" class="form-label">Collection Price</label>
                    <input type="number" class="form-control" id="collectionPrice" placeholder="Set price for the entire collection (optional)">
                </div>
                <button id="bulkUploadPhotos" type="button" class="btn btn-primary mt-3">Upload Photos with Watermark</button>
    

            </div>
        </div>
    </div>
    
    <div id="Manage_Events" class="media_tabs">
    
        <div  class="card mb-4 shadow-lg">
      <!-- Event Sorting and Filtering Section onchange="fetchEvents()"-->
      <div class="mb-4 card-body">
        <h5 class="mb-3">Sort & Filter Events</h5>
        <div class="form-inline">
            <input type="text" class="form-control mb-2 mr-2" id="eventFilter" placeholder="Search by name or description" onkeyup="fetchEvents()">
            <select  class="form-control mb-2" id="sortBy" >
                <option value="eventDate">Sort by Date</option>
                <option value="title">Sort by Name</option>
            </select>
        </div>
    </div>
</div>

    <!-- Event List with Edit & Delete Options -->
  
        <div id="eventList" class="card mb-4 shadow-lg">
            <h5 class="mb-3">Manage Events</h5>
            <div class="list-group" id="eventsContainer"></div>
        </div>
        <div id="eventMediaContainer">
         
            
        </div>
  
</div>

                <!-- Media Gallery Section -->

    <div id="Manage_Gallery" class="media_tabs">
<div id="mainGallerySection" class="card mb-4 shadow-lg">
    <h5 class="mb-3">Manage Gallery</h5>

    <div id="galleryContainer"></div>
</div>



 </div>

  </main>


  <div id="currentEventID" ></div>

 <!-- Add to Gallery Modal -->
 <div id="addToGalleryModal" class="modal" style="display:none;">
    <div class="modal-content">
        <h3>Add Media to Gallery</h3>
        <p>Select a category:</p>
        <button onclick="addMediaToGallery('portrait')">Portrait</button>
        <button onclick="addMediaToGallery('event')">Event</button>
        <button onclick="addMediaToGallery('commercial')">Commercial</button>
        <button onclick="addMediaToGallery('family')">Family</button>
        <button onclick="addMediaToGallery('other')">Other</button>
        <button onclick="closeModal()">Cancel</button>
    </div>
</div>


  <!-- Footer style="display: none;" -->
<footer class="bg-dark text-light py-3">
    <div class="container">
        <div class="row">
            <div class="col-md-6">
                <p>&copy; 2024 <a href="https://ShutterWorx.co" class="text-light">ShutterWorx</a> All rights reserved.</p>
            </div>
            <div class="col-md-6 text-md-right">
                <ul class="list-inline">
                    <li class="list-inline-item"><a href="https://ShutterWorx.co/FAQ" class="text-light">FAQs</a></li>
                    <li class="list-inline-item"><a href="https://ShutterWorx.co/join" class="text-light">Upgrade</a></li>
                    <li class="list-inline-item"><a href="https://ShutterWorx.co/contact" class="text-light">Contact Us</a></li>
                    <li class="list-inline-item"><a href="https://ShutterWorx.co/privacy" class="text-light">Privacy Policy</a></li>
                    <li class="list-inline-item"><a href="https://ShutterWorx.co/terms" class="text-light">Terms of Service</a></li>
                </ul>
            </div>
        </div>
    </div>
</footer>

<script src="../js/admin.js" ></script>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>


<!-- Firebase JS SDK and Custom Scripts -->

<script type="module">
    import { db, doc, getDoc, query, updateDoc, 
            setDoc, ref, signInWithPopup, orderBy,
            GoogleAuthProvider, FacebookAuthProvider, 
            uploadBytes, OAuthProvider, arrayUnion, getStorage ,
            signOut, addDoc, increment, onAuthStateChanged, 
            createUserWithEmailAndPassword, signInWithEmailAndPassword, 
            where, getDocs, storage, collection, 
            auth, analytics, deleteDoc, getDownloadURL } from '../js/module.js';








            function compressBase64Image(base64String, maxWidth = 800, maxHeight = 800) {
    return new Promise((resolve) => {
        const img = new Image();
        img.src = base64String;

        img.onload = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // Set canvas dimensions proportional to the max dimensions
            const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            // Draw the image on the canvas
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Convert the canvas back to Base64 (reduce quality if needed)
            resolve(canvas.toDataURL("image/jpeg", 0.8)); // 80% quality
        };
    });
}







    // Bulk Upload Photos Function
    async function bulkUploadPhotosFunc() {

     const eventId = document.getElementById('currentEventID').innerText;

    const photos = document.getElementById('photoUpload').files;
    const photoPrice = document.getElementById('photoPrice').value;
    const collectionPrice = document.getElementById('collectionPrice').value;
    const isPublic = document.getElementById('photoPublic').checked;
   
    console.log("eventId    ",eventId);
    if (photos.length === 0) {
        showToast("Please select at least one photo.", "error");
        return;
    }
    if (!eventId) {
        showToast("Add an Event", "error");
        return;
    }
    // Validation constants
    const MAX_FILE_SIZE_MB = 200;
    const VALID_FILE_TYPES = ["image/jpeg", "image/png", "image/webp", "image/bmp", "image/gif", "image/tiff", "image/svg+xml"];
    const invalidFiles = [];
    const uploadedFiles = [];

    const watermarkConfig = {
        text: document.getElementById('watermarkText').value,
        position: document.getElementById('watermarkPosition').value,
        opacity: parseFloat(document.getElementById('watermarkOpacity').value),
        logoFile: document.getElementById('logoOverlay').files[0],
        scale: parseFloat(document.getElementById('logoScale').value),
        fontSize: parseInt(document.getElementById('fontSize').value, 10),
        fontFamily: document.getElementById('fontFamily').value,
        gap: parseInt(document.getElementById('textGap').value, 10),
        fontColor: document.getElementById('fontColor').value,
    };

    for (const photo of photos) {
        const fileSizeMB = photo.size / (1024 * 1024);
        const fileType = photo.type;

        const watermarkedImage = await fileToDataURL(photo); // Convert to Base64
            const compressedImage = await compressBase64Image(watermarkedImage); // Compress the image

        if (!VALID_FILE_TYPES.includes(fileType)) {
            invalidFiles.push(`${photo.name} (Invalid type: ${fileType})`);
            continue;
        }

        if (fileSizeMB > MAX_FILE_SIZE_MB) {
            invalidFiles.push(`${photo.name} (Too large: ${fileSizeMB.toFixed(2)} MB)`);
            continue;
        }

        const photoRef = ref(storage, `eventPhotos/${eventId}/${cleanAndShortenFileName(photo.name)}`);
        try {
            // Upload original photo
            await uploadBytes(photoRef, photo);
            const photoUrl = await getDownloadURL(photoRef);

            // Apply watermark
            const photoDataUrl = await fileToDataURL(photo); // Convert file to base64
            const watermarkedImageUrl = await applyWatermark(
                photoDataUrl,
                watermarkConfig.text,
                watermarkConfig.position,
                watermarkConfig.opacity,
                watermarkConfig.logoFile,
                watermarkConfig.scale,
                watermarkConfig.fontSize,
                watermarkConfig.fontFamily,
                watermarkConfig.gap,
                watermarkConfig.fontColor
            );

            // Save details
            await savePhotoDetails(photoUrl, photoPrice, collectionPrice, isPublic, eventId, compressedImage, fileSizeMB, fileType);
            uploadedFiles.push(photo.name);

        } catch (error) {
            console.error("Error processing photo:", error);
            showToast(`Failed to upload ${photo.name}`, "error");
        }
    }

    // Notify user of results
    if (invalidFiles.length > 0) {
        showToast(`These files couldn't be uploaded:\n${invalidFiles.join("\n")}`, "warning");
    }

    if (uploadedFiles.length > 0) {
        showTabContent('Manage_Events');
       // showToast(`Successfully uploaded: ${uploadedFiles.join(", ")}`, "success");
        showToast(`Successfully uploaded: ${uploadedFiles.length}`, "success");
    }
}

// Helper to convert file to data URL (base64 string)
function fileToDataURL(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(e);
        reader.readAsDataURL(file);
    });
}

// Updated savePhotoDetails function
async function savePhotoDetails(photoUrl, photoPrice, collectionPrice, isPublic, eventId, watermarkedImageUrl, fileSize, fileType) {
    const photoDetails = {
        photoUrl,
        watermarkedImageUrl,
        eventId,
        price: photoPrice,
        collectionPrice,
        isPublic,
        timestamp: new Date(),
        fileSize: fileSize.toFixed(2),
        fileType,
        status: "active",
        views: 0,
        deactivated: false,
    };

    try {
        const watermarkedRef = ref(storage, `eventPhotos/${eventId}/watermarked_${Date.now()}.png`);
        const response = await fetch(watermarkedImageUrl);
        const blob = await response.blob();
        await uploadBytes(watermarkedRef, blob);

        const watermarkedUrl = await getDownloadURL(watermarkedRef);
        photoDetails.watermarkedImageUrl = watermarkedUrl;

        const docRef = await addDoc(collection(db, "Media"), photoDetails);
        console.log("Photo details saved with ID:", docRef.id);
    } catch (error) {
        console.error("Error saving photo details:", error);
        showToast("Error saving photo details to the database.", "error");
    }
}

async function handleFileUpload(event) { 
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const imageUrl = e.target.result; // Base64 string

            //console.log(imageUrl)
            currentPreviewImage = imageUrl;
            updatePreview(); // Ensure a valid string is passed here
        };
        reader.readAsDataURL(file);
    }
}

// Existing listeners
document.getElementById('photoUpload').addEventListener('change', handleFileUpload);

document.getElementById('watermarkText').addEventListener('input', () => updatePreview());
document.getElementById('watermarkPosition').addEventListener('change', () => updatePreview());
document.getElementById('watermarkOpacity').addEventListener('input', () => updatePreview());
document.getElementById('logoOverlay').addEventListener('change', () => updatePreview());
document.getElementById('logoScale').addEventListener('input', () => updatePreview());

// New listeners for additional functionalities
document.getElementById('fontSize').addEventListener('input', () => updatePreview());
document.getElementById('fontFamily').addEventListener('change', () => updatePreview());
document.getElementById('textGap').addEventListener('input', () => updatePreview());
document.getElementById('fontColor').addEventListener('input', () => updatePreview());




let currentPreviewImage = null;



async function updatePreview(imageUrl) {
    if (!imageUrl) {
        imageUrl = currentPreviewImage;
    }

    if (!imageUrl) {
        console.error("No image URL provided or uploaded.");
        return;
    }

    const text = document.getElementById('watermarkText').value;
    const position = document.getElementById('watermarkPosition').value;
    const opacity = parseFloat(document.getElementById('watermarkOpacity').value);
    const logoFile = document.getElementById('logoOverlay').files[0];
    const scale = parseFloat(document.getElementById('logoScale').value);
    const fontSize = parseInt(document.getElementById('fontSize').value, 10);
    const fontFamily = document.getElementById('fontFamily').value;
    const gap = parseInt(document.getElementById('textGap').value, 10);
    const fontColor = document.getElementById('fontColor').value;  // Get the selected color

    const previewCanvas = document.getElementById('watermarkPreview');
    const previewCtx = previewCanvas.getContext('2d');

    const img = new Image();
    img.src = imageUrl;

    img.onload = async function () {
        previewCanvas.width = img.width;
        previewCanvas.height = img.height;

        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.drawImage(img, 0, 0);

        try {
            const watermarkedImage = await applyWatermark(img.src, text, position, opacity, logoFile, scale, fontSize, fontFamily, gap, fontColor);
            const watermarkedImg = new Image();
            watermarkedImg.src = watermarkedImage;

            watermarkedImg.onload = function () {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.drawImage(watermarkedImg, 0, 0);
            };
        } catch (err) {
            console.error("Error applying watermark:", err);
        }
    };

    img.onerror = function () {
        console.error("Error loading image:", imageUrl);
    };
}
async function applyWatermark(imageUrl, text, position, opacity, logo, scale, fontSize, fontFamily, gap, fontColor) {
    const img = new Image();
    img.src = imageUrl;

    await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
    });

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = img.width;
    canvas.height = img.height;

    ctx.drawImage(img, 0, 0);

    // Apply text watermark
    if (text) {
        ctx.font = `${fontSize}px ${fontFamily}`;
        ctx.fillStyle = `rgba(${hexToRgb(fontColor).r}, ${hexToRgb(fontColor).g}, ${hexToRgb(fontColor).b}, ${opacity})`;

        if (position === "center") {
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, img.width / 2, img.height / 2);
        } else if (position === "diagonal") {
            ctx.save();
            ctx.translate(gap, gap);
            ctx.rotate(Math.PI / 4);
            ctx.fillText(text, img.width / 2, img.height / 2);
            ctx.restore();
        } else if (position === "horizontal") {
            const yStart = img.height / 2 - gap * 2;
            for (let y = yStart; y <= img.height; y += gap + fontSize) {
                ctx.fillText(text, img.width / 2, y);
            }
        }
    }

    // Apply logo watermark
    if (logo) {
        const logoImg = new Image();
        logoImg.src = URL.createObjectURL(logo);

        await new Promise((resolve, reject) => {
            logoImg.onload = resolve;
            logoImg.onerror = reject;
        });

        const logoWidth = logoImg.width * scale;
        const logoHeight = logoImg.height * scale;
        const x = img.width - logoWidth - 10;
        const y = img.height - logoHeight - 10;

        ctx.drawImage(logoImg, x, y, logoWidth, logoHeight);
    }

    // Return the watermarked image as a data URL
    return canvas.toDataURL("image/png");
}

// Helper function to convert hex color to RGB for fillStyle
function hexToRgb(hex) {
    // Ensure hex starts with # and is 7 characters long
    hex = hex.replace(/^#/, '');
    if (hex.length === 3) {
        hex = hex.split('').map(function (hexChar) {
            return hexChar + hexChar;
        }).join('');
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return { r, g, b };
}

function generateAccessHandshake(extra) {
    const characters =  `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789${extra}`;
    let accessHandshake = "";

    for (let i = 0; i < 5; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        accessHandshake += characters[randomIndex];
    }

    return accessHandshake;
}





async function uploadEvent() {
    const title = document.getElementById('eventTitle').value.trim();
    const description = document.getElementById('eventDescription').value.trim();
    const eventDate = document.getElementById('eventDate').value.trim();
    const cover = document.getElementById('eventCover').files[0];
    const accessCode = document.getElementById('accessCode').value.trim();
    const location = document.getElementById('location').value.trim();

    // Client-side validation
    if (!title || !description || !eventDate || !cover) {
        showToast("Please fill in all required fields.", "error");
        return;
    }

    if (cover.size > 10 * 1024 * 1024) { // 10 MB limit
        showToast("File size is too large. Please upload a file less than 10MB.", "error");
        return;
    }

    const storageRef = ref(storage, `eventCovers/${cleanAndShortenFileName(title)}/cover.jpg`);
    try {
        // Upload cover image to Firebase Storage
        await uploadBytes(storageRef, cover);
        const coverUrl = await getDownloadURL(storageRef);

        // Generate access handshake code
        const handshakeCode = generateAccessHandshake();
        const downloadId = generateAccessHandshake("#^&@!");

        // Add event to Firestore and get the document reference
        const docRef = await addDoc(collection(db, 'Events'), {
            title,
            description,
            eventDate,
            coverUrl,
            shortURL: "",
            retrieveCount: 0,
            retriever_IP: [],
            accessHandShake: handshakeCode,
            downloadId: downloadId,
            status: "active",
            isPublic: true,
            collection_price: "",
            collection_OnSellPrice: "",
            type: "Free", /* Paid */
            eventTags: [], /* Implment */
            accessCode: accessCode || "",
            location: location || "",
            timestamp: new Date(),
            comments: [], /* Implment */
            views: 0,
            deactived: false,
            galleryBool: true
        });

        const eventID = docRef.id; // Get the document ID
     //   console.log("Event ID:", eventID); // Optional: Log it
        document.getElementById("currentEventID").innerText = eventID; // Display the ID

        // Trigger additional action after saving
        onEventSaved(eventID);

        showToast("Event uploaded successfully.", "success");
        document.getElementById('eventForm').reset();
        fetchEvents(); // Refresh event list
        showTabContent('Add_Media');
    } catch (error) {
        console.error("Error uploading event:", error);
        showToast("An error occurred while uploading the event.", "error");
    }
}

// Function to handle actions after an event is saved
function onEventSaved(eventID) {
    // Example: Send the event ID to an API or log it for analytics
    console.log(`Event saved with ID: ${eventID}`);
    // Add your API call or additional logic here
}









   // Fetch and display events with sorting and filtering
    async function fetchEvents() {
    const filterText = document.getElementById('eventFilter').value.toLowerCase();
    const sortBy = document.getElementById('sortBy').value;
    const eventList = document.getElementById('eventsContainer');
    eventList.innerHTML = ''; // Clear previous list

    const eventsCollection = collection(db, 'Events');
    let eventQuery;

    // Sort events
    if (sortBy === 'date') {
        eventQuery = query(eventsCollection, orderBy('eventDate'));
    } else {
        eventQuery = query(eventsCollection, orderBy('title'));
    }

    try {
        const snapshot = await getDocs(eventQuery);

      snapshot.forEach((doc) => {
    const event = doc.data();

    // Fallbacks for missing or null event properties
    const title = event.title || 'Untitled Event';
    const description = event.description || 'No description available';
    const eventDate = event.eventDate ? new Date(event.eventDate).toLocaleDateString() : 'Date not available';
    const coverUrl = event.coverUrl || 'default-thumbnail.png'; // Default if coverUrl is missing
    const retrieveCount = event.retrieveCount || 0;
    const status = event.status || true;
    const isPublic = event.isPublic || false;
    const collectionPrice = event.collection_price || 'Not set';
    const eventTags = event.eventTags || 'No tags';
    const location = event.location || 'Location not provided';
    const timestamp = event.timestamp ? new Date(event.timestamp.seconds * 1000).toLocaleString() : 'Timestamp not available';
    const comments = event.comments || 'No comments';
    const views = event.views || 0;
    const galleryBool = event.galleryBool ? 'Enabled' : 'Disabled';

    // Filter matching events
    if (
        title.toLowerCase().includes(filterText) ||
        description.toLowerCase().includes(filterText)
    ) {
        const eventItem = document.createElement('div');
        eventItem.classList.add('list-group-item', 'd-flex', 'flex-column', 'align-items-start', 'm-3', 'p-3');
        eventItem.style.border = '1px solid #ddd';
        eventItem.style.borderRadius = '8px';
        eventItem.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
console.log("doc.id    ",doc.id);


        // Collapsible content
        const detailsId = `details-${doc.id}`;
        const mediaListId = `mediaList-${doc.id}`;
        const eventDetails = `eventDetails-${doc.id}`;
        eventItem.innerHTML = `
    <div class="d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
                <strong>${title}</strong>
                <p style="margin: 0; font-size: 0.9rem; color: #666;">${eventDate}</p>
            
        <div class="align-items-center">

            <img class="eventCoverThumbnail" src="${coverUrl}" alt="Event Thumbnail" style="width: 60px; height: 60px; margin-right: 15px; border-radius: 4px;" />
            <div>
</div>
        </div>

        <div class="batch-buttons btn-group controls">
            <button class="btn btn-primary btn-sm" onclick="viewMedia('${doc.id}', '${title}', '${eventDate}', ${isPublic}, '${coverUrl}')">View Media</button>
            <button class="btn btn-warning btn-sm" onclick='editEvent("${doc.id}", ${JSON.stringify(event)})'>Edit</button>
            <button class="btn btn-danger btn-sm" onclick="deleteEvent('${doc.id}')">Delete</button>
            <button class="btn btn-primary btn-sm" onclick="addMedia('${doc.id}')">Add Media</button>
        </div>
    </div>


    <div class="mainEventPanel">
    <button class="btn btn-link mt-2 text-decoration-none" style="font-size: 0.9rem;" onclick="toggleMediaDetails('${detailsId}')">
        ${isPublic ? 'Hide' : 'Show'} Details
    </button>

    <div class="eventPanel">
    <div id="m-Details-${detailsId}" class="collapse mt-3">
        <p><strong>Description:</strong> ${description}</p>
        <p><strong>Status:</strong> <span class="badge ${status ? 'bg-success' : 'bg-danger'}">${status ? "Yes" : "No"}</span></p>
        <p><strong>Tags:</strong> ${eventTags}</p>
        <p><strong>Location:</strong> ${location}</p>
        <p><strong>Collection Price:</strong> $${collectionPrice}</p>
        <p><strong>Views:</strong> ${views}</p>
        <p><strong>Retrieve Count:</strong> ${retrieveCount}</p>
        <p><strong>Timestamp:</strong> ${timestamp}</p>
        <p><strong>Gallery Enabled:</strong> ${galleryBool}</p>
        <p><strong>Comments:</strong> ${comments}</p>
        <button class="btn btn-secondary btn-sm" onclick="viewAnalytics('${doc.id}')">View Analytics</button>
    </div>

    <div id='${eventDetails}' class="event_details_cover ">
    </div>
    </div>
        <div>

    <div>

    <div id='${mediaListId}' class="event_photos_list">
    </div>
`;


        eventList.appendChild(eventItem);
        console.log("eventDetails.id    ",eventDetails);

}
});
} catch (error) {
console.error("Error fetching events:", error);
}
}


// Function to toggle collapsible details
function toggleMediaDetails(mediaId) {

    const details = document.getElementById(`m-Details-${mediaId}`);
    const image = document.getElementById(`m-Image-${mediaId}`);
    
    details.classList.toggle('collapse');
    image.classList.toggle('collapse');
}

// Function to handle analytics view
function viewAnalytics(eventId) {
    alert(`Viewing analytics for event ID: ${eventId}`);
    
    // Navigate to the analytics page, passing the event ID as a URL parameter
    window.location.href = `../admin/analytics?eventId=${eventId}`;
}


        






let eventInfo = '';

async function viewMedia(eventId, eventTitle, eventDate, publicStatus, coverPhoto) {
    const mediaCollectionRef = collection(db, "Media");
    const mediaQuery = query(mediaCollectionRef, where("eventId", "==", eventId));
    const mediaSnapshot = await getDocs(mediaQuery);
    const mediaListContainer = document.getElementById(`mediaList-${eventId}`);
    const eventDetailsContainer = document.getElementById(`eventDetails-${eventId}`);

    //const mediaListContainer = document.getElementById("mediaList");
    //const eventDetailsContainer = document.getElementById("eventDetails");

    // Reset containers
    mediaListContainer.innerHTML = "";
    eventDetailsContainer.innerHTML = "";

    let imageCount = 0;
     eventInfo = [eventId, eventTitle, eventDate, publicStatus, coverPhoto];
     const mediaItems = [];

    mediaSnapshot.forEach((doc) => {
        const data = doc.data();
        imageCount++;
        mediaItems.push({ id: doc.id, ...data });

        // Use the first image as the cover photo
        if (!coverPhoto) coverPhoto = data.photoUrl;
    });
    
    // View Media Button
    eventDetailsContainer.innerHTML = `
        <h3>${eventTitle}</h3>
        <p>Date: ${eventDate}</p>
        <p>Public: <span class="badge ${publicStatus ? 'bg-success' : 'bg-danger'}">${publicStatus ? "Yes" : "No"}</span></p>
<div class="manageEventsArea">
        <img src="${coverPhoto}" alt="Event Cover Photo" class="event-cover">
        <p>Total Images: ${imageCount}</p>
        <div class="batch-buttons btn-group controls">

            <button onclick="batchSetPublic('${eventId}', true)">Set All Public</button>
            <button onclick="batchSetPublic('${eventId}', false)">Set All Private</button>
            <button onclick="batchUpdatePrices('${eventId}')">Update All Prices</button>
        </div>
        </div>
    `;

    // Generate media items
    mediaItems.forEach((item) => {
        const mediaDiv = document.createElement("div");
        mediaDiv.classList.add("media-item");
        mediaDiv.id.add(`media-item-${item.id}`);        
        mediaDiv.innerHTML = `
            <div class="media-header">
                               
                <button onclick="toggleMediaDetails('${item.id}')">View Details</button>
           
                <div class="media-item-img-details">

                <div id="m-Image-${item.id}" class="media-image view-image" data-image-id='${item.id}'>
                <img 
                    data-src="${item.photoUrl}" 
                    alt="Media" 
                    class="media-thumbnail lazy"
                >
                </div>
            <div id="m-Details-${item.id}" class="media-details collapse">
                <p>File Type: ${item.fileType}</p>
                <p>File Size: ${item.fileSize} MB</p>
                <p>Status: ${item.status}</p>
                <p>Views: ${item.views}</p>
                <p>Timestamp: ${new Date(item.timestamp.seconds * 1000).toLocaleString()}</p>
                        <p>Price: $${item.price}</p>
                <p>Collection Price: $${item.collectionPrice}</p>
            </div>

      </div>
                <div class="batch-buttons btn-group controls">
                      <button onclick=" addToMainGallery('${item.id}')">Add to Gallery</button>

                <button onclick="togglePublicStatus('${item.id}', ${!item.isPublic})">
                    ${item.isPublic ? "Make Private" : "Make Public"}
                </button>
                <button class="btn btn-danger btn-sm" onclick="removeFromMedia('${item.id}')">Delete</button>
            </div>

            </div>

        `;
        mediaListContainer.appendChild(mediaDiv);
    });

    // Initialize lazy loading
    initializeLazyLoading();
}

// Lazy loading implementation
function initializeLazyLoading() {
    const lazyImages = document.querySelectorAll(".lazy");
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.classList.remove("lazy");
                observer.unobserve(img);
            }
        });
    });

    lazyImages.forEach((img) => observer.observe(img));
}

// Batch set public/private
async function batchSetPublic(eventId, isPublic) {
    const mediaCollectionRef = collection(db, "Media");
    const mediaQuery = query(mediaCollectionRef, where("eventId", "==", eventId));
    const mediaSnapshot = await getDocs(mediaQuery);

    const batch = writeBatch(db);
    mediaSnapshot.forEach((doc) => {
        batch.update(doc.ref, { isPublic });
    });

    await batch.commit();
    alert(`All media set to ${isPublic ? "Public" : "Private"}.`);
    viewMedia(eventInfo); // Refresh the view
}
window.batchSetPublic = batchSetPublic;

// Batch update prices
async function batchUpdatePrices(eventId) {
    const newPrice = prompt("Enter the new price for all media:");
    if (!newPrice || isNaN(newPrice)) {
        alert("Invalid price.");
        return;
    }

    const mediaCollectionRef = collection(db, "Media");
    const mediaQuery = query(mediaCollectionRef, where("eventId", "==", eventId));
    const mediaSnapshot = await getDocs(mediaQuery);

    const batch = writeBatch(db);
    mediaSnapshot.forEach((doc) => {
        batch.update(doc.ref, { price: parseFloat(newPrice) });
    });

    await batch.commit();
    alert("Prices updated successfully.");
    viewMedia(eventInfo); // Refresh the view
}
window.batchUpdatePrices = batchUpdatePrices;


// Function to toggle the public status
async function togglePublicStatus(docId, newStatus) {
    const docRef = doc(db, "Media", docId);
    await updateDoc(docRef, { isPublic: newStatus });
    alert(`Photo is now ${newStatus ? "Public" : "Private"}`);
    viewMedia(eventInfo); // Refresh the list
}
window.togglePublicStatus = togglePublicStatus;

// Function to update the price
async function updatePrice(docId) {
    const newPrice = prompt("Enter the new price:");
    if (!newPrice || isNaN(newPrice)) {
        alert("Invalid price.");
        return;
    }
    const docRef = doc(db, "Media", docId);
    await updateDoc(docRef, { price: parseFloat(newPrice) });
    alert("Price updated successfully.");
    viewMedia(eventInfo); // Refresh the list
}
window.updatePrice = updatePrice;










    // Edit Event Function
    function editEvent(eventId, event) {
    //    let Event = JSON.stringify(event);

        document.getElementById('eventTitle').value = event.title;
        document.getElementById('eventDescription').value = event.description;
        document.getElementById('eventDate').value = event.eventDate;
        document.getElementById('accessCode').value = event.accessCode;
        document.getElementById('uploadEventBTN').disabled;
        document.getElementById('currentEventID').innerText = eventId;

        document.getElementById('Add_Event_Label').innerText = "Update Event";
        showTabContent('editEvent');

    }

// Save Event Function
async function saveEvent() {
    console.log("eventCoverArea??????");
    const eventId = document.getElementById('currentEventID').innerText.trim();
    if (!eventId) {
        console.error("No current event ID found.");
        showToast("Error: No event selected to save.", "error");
        return;
    }

    // Get updated event details from the form fields
    const updatedEvent = {
        title: document.getElementById('eventTitle').value.trim(),
        description: document.getElementById('eventDescription').value.trim(),
        eventDate: document.getElementById('eventDate').value.trim(),
        accessCode: document.getElementById('accessCode').value.trim(),
    };

    // Validate input
    if (!updatedEvent.title || !updatedEvent.eventDate) {
        showToast("Please fill out the required fields.", "warning");
        return;
    }

    try {
        // Update the event in Firestore
        const eventRef = doc(db, 'Events', eventId);
        await updateDoc(eventRef, updatedEvent);

        showToast('Event saved successfully!', "success");

        // Optional: Re-enable the upload button if needed
        document.getElementById('uploadEventBTN').disabled = false;

        // Optional: Refresh events list or close modal
        fetchEvents();
    } catch (error) {
        console.error("Error saving event:", error);
        showToast("Error saving event. Please try again.", "error");
    }
}

async function removeFromMedia(eventId) {
    try {
        // Query the Media collection for documents with the specified eventId
        const mediaQuery = query(collection(db, 'Media'), where('eventId', '==', eventId));
        const mediaSnapshot = await getDocs(mediaQuery);

        // Delete each matching document
        const deletePromises = mediaSnapshot.docs.map(async (mediaDoc) => {
            try {
                await deleteDoc(doc(db, 'Media', mediaDoc.id));
            } catch (err) {
                console.error("Error deleting media document:", err);
            }
        });

        // Wait for all deletions to complete
        await Promise.all(deletePromises);

        // Show success toast once all deletions are complete
        showToast('Event deleted successfully');
    } catch (error) {
        console.error("Error querying or deleting media documents:", error);
        showToast('Failed to delete event media');
    }
}


window.removeFromMedia = removeFromMedia;

    // Delete Event Function
// Delete Event Function 
async function deleteEvent(eventId) {
    if (confirm('Are you sure you want to delete this event?')) {
        try {
            // Fetch the event document
            const eventRef = doc(db, 'Events', eventId);
            const eventSnap = await getDoc(eventRef);

            if (eventSnap.exists()) {
                const eventData = eventSnap.data();

                // Delete images from Firebase Storage
                const storage = getStorage();
                const watermarkedImageRef = ref(storage, eventData.watermarkedImageUrl);
                const photoRef = ref(storage, eventData.photoUrl);

                // Delete watermarked image
                if (eventData.watermarkedImageUrl) {
                    await deleteObject(watermarkedImageRef).catch(err => 
                        console.error("Error deleting watermarked image:", err)
                    );
                }

                // Delete original photo
                if (eventData.photoUrl) {
                    await deleteObject(photoRef).catch(err => 
                        console.error("Error deleting photo:", err)
                    );
                }

                
                // Delete associated media from Media collection
                const mediaQuery = query(collection(db, 'Media'), where('eventId', '==', eventId));
                const mediaSnapshot = await getDocs(mediaQuery);
                mediaSnapshot.forEach(async (mediaDoc) => {
                    await deleteDoc(doc(db, 'Media', mediaDoc.id)).catch(err => 
                        console.error("Error deleting media document:", err)
                    );
                });

                // Delete associated media from MainGallery collection
                const galleryQuery = query(collection(db, 'MainGallery'), where('eventId', '==', eventId));
                const gallerySnapshot = await getDocs(galleryQuery);
                gallerySnapshot.forEach(async (galleryDoc) => {
                    await deleteDoc(doc(db, 'MainGallery', galleryDoc.id)).catch(err => 
                        console.error("Error deleting gallery document:", err)
                    );
                });

                // Delete the event itself
                await deleteDoc(eventRef);
                showToast('Event deleted successfully');
                fetchEvents(); // Refresh event list
            } else {
                console.error("Event not found for deletion");
            }
        } catch (error) {
            console.error("Error deleting event:", error);
        }
    }
}

    

    async function addMediaToGallery(category) {
    const [eventId, eventTitle, eventDate, publicStatus, coverPhoto] = eventInfo;
    
    // Get the selected media
    const mediaCollectionRef = collection(db, "Media");
    const mediaQuery = query(mediaCollectionRef, where("eventId", "==", eventId));
    const mediaSnapshot = await getDocs(mediaQuery);
    
    // Get the media details and send to MainGallery
    mediaSnapshot.forEach(async (doc) => {
        const mediaData = doc.data();
        const mediaId = doc.id;
        const { photoUrl, status, price, isPublic, watermarkedImageUrl } = mediaData;

        // Prepare the data to be added to MainGallery
        const mainGalleryData = {
            eventId: eventId,
            mediaId: mediaId,
            category: category, // Portrait, Event, Commercial, Family, Other
            isPublic: isPublic,
            photoUrl: photoUrl,
            status: status,
            watermarkedImageUrl: watermarkedImageUrl,
            price: price,
            appearOnHeader: false
        };

        // Add the media to the MainGallery collection
        await addDoc(collection(db, "MainGallery"), mainGalleryData);

        // Optionally display a success message
        alert('Media successfully added to the gallery!');
    });

    // Close the modal after adding the media
    closeModal();
}



    function openAddToGalleryModal() {
    // Show the modal
    document.getElementById("addToGalleryModal").style.display = "block";
}
function closeModal() {
    // Hide the modal
    document.getElementById("addToGalleryModal").style.display = "none";
}




/**
 * Load media items from MainGallery collection and render them into the gallery container.
 */
 async function loadMainGallery() { 
    const galleryContainer = document.getElementById('galleryContainer');
    galleryContainer.innerHTML = ''; // Clear previous content


        try {
        // Step 1: Fetch all documents from the MainGallery collection
        const mainGalleryRef = collection(db, "MainGallery");
        const mainGallerySnapshot = await getDocs(mainGalleryRef);

        if (mainGallerySnapshot.empty) {
            console.log("No documents found in MainGallery.");
            showToast('No documents found in MainGallery.', 'info');
            return;
        }

        // Step 2: Create an array of imageIds from MainGallery
        const mainGalleryIds = [];
        mainGallerySnapshot.forEach(doc => {
            mainGalleryIds.push(doc.id); // Save the doc ID from MainGallery
        });

        // Step 3: Fetch all documents from the Media collection
        const mediaRef = collection(db, "Media");
        const mediaSnapshot = await getDocs(mediaRef);

        if (mediaSnapshot.empty) {
            console.log("No documents found in Media.");
            showToast('No documents found in Media.', 'info');
            return;
        }

        // Step 4: Match the document IDs between MainGallery and Media
        const matchingIds = [];
        mediaSnapshot.forEach(doc => {
            if (mainGalleryIds.includes(doc.id)) {
                matchingIds.push(doc.id); // Match IDs and add to the result array

                
            const mediaData = doc.data();
            const mediaId = doc.id;
            const { photoUrl, category, price, status, isPublic, watermarkedImageUrl, appearOn = {} } = mediaData;

            // Ensure appearOn has default values if it's missing
            const defaultAppearOn = {
                HomePage: false,
                AboutPage: false,
                EventPage: false,
                ContactPage: false,
                MainGallery: false
            };

            // Merge appearOn with default values
            const appearOnData = { ...defaultAppearOn, ...appearOn };

            // Create media item card
            const mediaDiv = document.createElement('div');
            mediaDiv.classList.add('gallery-item', 'card-body');
            mediaDiv.innerHTML = `
<div class="media-container">
  <div class="media-header">
    <div class="flex">
      <div class="box">
        <img src="${photoUrl}" alt="Media Image" class="media-thumbnail view-image" data-image-id="${mediaId}">

      </div>
      <div class="box">
        <img src="${watermarkedImageUrl}" alt="Watermarked Image" class="media-thumbnail">

        <button onclick="toggleCollapse('appearOn-${mediaId}', this)">Expand </button>

      </div>

    </div>
  </div>

  <div id="details-${mediaId}" class="gallery-details ">

    <div class="box">
      <h4>${category || ''}</h4>
      <p>Status: ${status}</p>
      <p>Public: ${isPublic ? "Yes" : "No"}</p>

      <p>Price: $${price}</p>
    </div>
  </div>
</div>

<div id="appearOn-${mediaId}" class="appearOnContainer media-actions collapse">
  <div class="appearOn">
    <h3>Appear On</h3>

    <div id="checkboxes-${mediaId}" class="checkbox-group">
      ${renderCheckboxes(['HomePage', 'AboutPage', 'EventPage', 'ContactPage', 'MainGallery'], appearOnData)}
    </div>
    <div class="controls">
      <button onclick="handleUpdate('${mediaId}')">Update</button>
      <button onclick="removeMedia('${mediaId}')">Remove</button>
    </div>

  </div>

</div>
            `;

            galleryContainer.appendChild(mediaDiv);
    
            }
        });

        // Step 5: Log or process the matching document IDs
        if (matchingIds.length > 0) {
            console.log("Matching document IDs:", matchingIds);
            showToast('Matching IDs found.', 'success');
            return matchingIds;
        } else {
            console.log("No matching document IDs found.");
            showToast('No matching document IDs found.', 'info');
            return [];
        }

    
} catch (error) {
        console.error('Error loading gallery:', error);
        galleryContainer.innerHTML = "<p>Error loading gallery. Please try again later.</p>";
    }

    }

/*
  

    */



/**
 * Render checkboxes for the appearOn settings and set their checked state based on the provided appearOn data.
 * @param {Array<string>} options - Array of checkbox labels/values.
 * @param {Object} appearOn - An object indicating which pages the media should appear on (true or false for each page).
 * @returns {string} - HTML string for the checkbox inputs, with checked checkboxes where applicable.
 */
function renderCheckboxes(options, appearOn) {
    return options
        .map(option => {
            const checked = appearOn[option] ? 'checked' : '';  // Check if the option is true in appearOn
            return `
                <div>
                    <input type="checkbox" id="${option}" value="${option}" ${checked}>
                    <label for="${option}">${option}</label>
                </div>
            `;
        })
        .join('');
}

/**
 * Handle updating the appearOn field for a media item.
 * @param {string} mediaId - The ID of the media document to update.
 */
function handleUpdate(mediaId) {
    const checkboxes = document.querySelectorAll(`#checkboxes-${mediaId} input[type="checkbox"]`);
    const selectedPages = Array.from(checkboxes)
        .filter(checkbox => checkbox.checked)
        .map(checkbox => checkbox.value);

    updateAppearOn(mediaId, selectedPages);
}






// Toggle the collapse of media details
function toggleCollapse(mediaId, btnDiv) {
    const details = document.getElementById(mediaId);

    // Toggle the 'collapse' class
    details.classList.toggle('collapse');

    // Update the button content
    if (btnDiv) {
        if (details.classList.contains('collapse')) {
            btnDiv.innerHTML = 'Expand '; // Set to collapsed state
        } else {
            btnDiv.innerHTML = 'Collapse '; // Set to expanded state
        }
    }
}




// Function to add a document ID to MainGallery
async function addToMainGallery(imageId) {
    try {
        // Create a reference to the 'MainGallery' collection and set the document with the given ID
        const imageDocRef = doc(collection(db, 'MainGallery'), imageId);

        // Data to store in the document
        const mainGalleryData = {
            imageId, // Store the image ID
            timestamp: new Date(), // Optional: Add a timestamp
            status: "active", // Optional: Add a status
        };

        // Add the data to Firestore
        await setDoc(imageDocRef, mainGalleryData);

        console.log(`Image with ID ${imageId} added to MainGallery.`);
        showToast('Image successfully added to MainGallery!', 'success');
    } catch (error) {
        console.error("Error adding image to MainGallery:", error);
        showToast('Failed to add image to MainGallery.', 'error');
    }
}







/**
 * Update the appearOn field for a specific media item in Firestore.
 * @param {string} imageId - The ID of the media document.
 * @param {Array<string>} selectedPages - The selected pages to update the appearOn array.
 */

// Function to update appearOn array in Firestore
async function updateAppearOn(imageId, selectedPages) {
    try {
        const imageDocRef = doc(collection(db, 'MainGallery'), imageId);

        await updateDoc(imageDocRef, { appearOn: selectedPages });

        showToast(`Successfully updated appearOn for media ID: ${imageId}`, 'success');
    } catch (error) {
        console.error('Error updating appearOn array:', error);
        showToast(`Error updating appearOn for media ID: ${imageId}`, 'error');
    }
}

// Remove Media Function
async function removeMedia(mediaId) {
    const confirmDelete = confirm("Are you sure you want to remove this media from the gallery?");
    if (confirmDelete) {
        // Remove from MainGallery collection
        await deleteDoc(doc(db, "MainGallery", mediaId));
        alert('Media successfully removed from the gallery!');
        loadMainGallery(); // Refresh the gallery list
    }
}

function addMediaToEvent(){
    const eventID = document.getElementById("currentEventID");
    
    document.getElementById("addMedia").style.display = 'block';
    addMedia(eventID);
}

function addMedia(eventID){
    document.getElementById("currentEventID").innerText = eventID;

    showTabContent('Add_Media');
}






// Save watermark input values
function saveWatermarkInputs() {
    const addMediaDiv = document.getElementById("Add_Media");
    const inputs = addMediaDiv.querySelectorAll("input:not([type='file']), select, textarea"); // Exclude file inputs
    const watermarkValues = {};

    inputs.forEach((input) => {
        watermarkValues[input.id] = input.type === "checkbox" ? input.checked : input.value; // Save value or checkbox state
    });

    localStorage.setItem("watermarkInputs", JSON.stringify(watermarkValues));
    showToast("Watermark input values saved.", "success");
}

// Load watermark input values
function loadWatermarkInputs() {
    const savedValues = JSON.parse(localStorage.getItem("watermarkInputs"));
    if (!savedValues) {
        showToast("No saved input values found.", "info");
        return;
    }

    const addMediaDiv = document.getElementById("Add_Media");
    const inputs = addMediaDiv.querySelectorAll("input:not([type='file']), select, textarea");

    inputs.forEach((input) => {
        if (savedValues.hasOwnProperty(input.id)) {
            if (input.type === "checkbox") {
                input.checked = savedValues[input.id]; // Restore checkbox state
            } else {
                input.value = savedValues[input.id]; // Restore input value
            }
        }
    });

    showToast("Watermark input values loaded.", "success");
}

// Clear watermark input values
function clearWatermarkInputs() {
    const addMediaDiv = document.getElementById("Add_Media");
    const inputs = addMediaDiv.querySelectorAll("input:not([type='file']), select, textarea");

    inputs.forEach((input) => {
        if (input.type === "checkbox") {
            input.checked = false; // Clear checkbox
        } else {
            input.value = ""; // Clear input value
        }
    });

    localStorage.removeItem("watermarkInputs"); // Remove saved values
    showToast("Watermark input values cleared.", "success");
}

// Save inputs on close, refresh, or tab navigation
window.addEventListener("beforeunload", (event) => {
    saveWatermarkInputs();
});





    document.addEventListener('DOMContentLoaded', () => {
       
        fetchEvents(); 

loadMainGallery();

        
        window.addMediaToGallery = addMediaToGallery;

        window.openAddToGalleryModal = openAddToGalleryModal;
        window.closeModal = closeModal;

        window.applyWatermark = applyWatermark;
        window.editEvent = editEvent;

        window.uploadEvent = uploadEvent;

        window.fetchEvents = fetchEvents;
        window.viewMedia = viewMedia;

        window.deleteEvent = deleteEvent;
        window.saveEvent = saveEvent;
        window.toggleMediaDetails  = toggleMediaDetails ;

window.loadMainGallery = loadMainGallery;

window.viewAnalytics = viewAnalytics;
window.addMedia = addMedia;
window.toggleCollapse  = toggleCollapse;
window.showTabContent = showTabContent;
window.updateAppearOn = updateAppearOn;
window.removeMedia = removeMedia;

window.handleFileUpload = handleFileUpload;
window.updatePreview = updatePreview;

window.renderCheckboxes = renderCheckboxes;
window.handleUpdate  = handleUpdate ;

window.batchSetPublic   = batchSetPublic  ;
window.addMediaToEvent = addMediaToEvent;
window.bulkUploadPhotosFunc = bulkUploadPhotosFunc;
window.fileToDataURL = fileToDataURL;
window.savePhotoDetails = savePhotoDetails;
 window.addToMainGallery  = addToMainGallery ;
window.saveWatermarkInputs = saveWatermarkInputs;
window.clearWatermarkInputs = clearWatermarkInputs;
window.loadWatermarkInputs = loadWatermarkInputs;
loadWatermarkInputs();

window.generateAccessHandshake = generateAccessHandshake;

const bulkUploadPhotosBTN = document.getElementById('bulkUploadPhotos');
    if (bulkUploadPhotosBTN) {
        bulkUploadPhotosBTN.addEventListener('click', bulkUploadPhotosFunc);
    }

        const saveEventBTN = document.getElementById('saveEvent');
    if (saveEventBTN) {
        saveEventBTN.addEventListener('click', saveEvent);
    }

    // Listener for the "Upload Event" button
    const uploadEventButton = document.getElementById('uploadEventBTN');
    if (uploadEventButton) {
        uploadEventButton.addEventListener('click', uploadEvent);
    }


    // Listener for the "Sort by" dropdown
    const sortByDropdown = document.getElementById('sortBy');
    if (sortByDropdown) {
        sortByDropdown.addEventListener('change', fetchEvents);
    }



// Function to show content for a selected tab
function showTabContent(tabId) {

    
    if(tabId == "editEvent"){
        document.getElementById('Add_Event_Label').innerText = "Update Event";
        document.getElementById('saveEvent').style.display = "block";
        document.getElementById('eventCoverArea').style.display = "none";
        document.getElementById('uploadEventBTN').style.display = "none";
        document.getElementById("addMedia").style.display = 'block';
       // showTabContent('editEvent');
        tabId = "Add_Event";
    }else{       
        document.getElementById('saveEvent').style.display = "none";
        document.getElementById('eventCoverArea').style.display = "block";
        document.getElementById('uploadEventBTN').style.display = "block";
        document.getElementById('Add_Event_Label').innerText = "Add New Event";
        document.getElementById("addMedia").style.display = 'none';

    }
    // Hide all tab content
    const allTabs = document.querySelectorAll('.media_tabs');
    allTabs.forEach((tab) => {
        tab.style.display = 'none';
    });

    // Remove 'active' class from all buttons
    const allButtons = document.querySelectorAll('.tabButton');
    allButtons.forEach((button) => {
        button.classList.remove('active');
    });

    // Show the selected tab content and activate the button
    const selectedTab = document.getElementById(tabId);
    if (selectedTab) {
        selectedTab.style.display = 'block';
        const activeButton = document.querySelector(`.tabButton[onclick="showTabContent('${tabId}')"]`);
        if (activeButton) activeButton.classList.add('active');

        // Save the selected tab to local storage
        localStorage.setItem('activeTab', tabId);
    }
}

// Function to load the last selected tab on page load
function loadLastTab() {
    // Retrieve the last active tab from local storage
    const savedTab = localStorage.getItem('activeTab');
console.log("savedTab");
    // Show the saved tab if it exists, otherwise show the default tab
    if (savedTab) {
        showTabContent(savedTab);
    } else {
        showTabContent('Add_Event'); // Default tab
    }
}

// Run on page load
loadLastTab();

// Add an event listener to the file input to handle the file selection
document.getElementById('eventCover').addEventListener('change', function(event) {
    const file = event.target.files[0]; // Get the selected file

    if (file) {
        const reader = new FileReader();

        // When the file is loaded, update the image preview
        reader.onload = function(e) {
            const coverPreview = document.getElementById('eventCoverPreview');
            coverPreview.src = e.target.result; // Set the preview image source to the data URL of the file
        };

        reader.readAsDataURL(file);
    }
});

// Add an event listener to the image preview that triggers when the image is clicked
document.getElementById('eventCoverPreview').addEventListener('click', function() {
    document.getElementById('eventCover').click();

});





// Add an event listener to the image preview that triggers when the image is clicked
document.getElementById('photoUploadBTN').addEventListener('click', function() {
    document.getElementById('photoUpload').click();

});
document.getElementById('watermarkPreview').addEventListener('click', function() {
    document.getElementById('photoUpload').click();

});


document.getElementById('logoOverlay').addEventListener('change', function(event) {
    const file = event.target.files[0]; // Get the selected file

    if (file) {
        const reader = new FileReader();

        // When the file is loaded, update the image preview
        reader.onload = function(e) {
            const logoOverlayPreview = document.getElementById('logoOverlay');
            logoOverlayPreview.src = e.target.result; // Set the preview image source to the data URL of the file
        };

        reader.readAsDataURL(file);
    }
});

// Add an event listener to the image preview that triggers when the image is clicked
document.getElementById('logoOverlayPreview').addEventListener('click', function() {
    document.getElementById('logoOverlay').click();

});
function showTab(tabId) {
        // Hide all watermark tab content
        var allTabs = document.querySelectorAll('.watermarkTabs');
        allTabs.forEach(function(tab) {
            tab.style.display = 'none';
        });

        // Show the selected tab
        var selectedTab = document.getElementById(tabId);
        if (selectedTab) {
            selectedTab.style.display = 'block';
        }
    }

    // Initially show the first tab or set the default tab to be visible
    window.onload = function() {
        document.getElementById('tabSelector').value = 'fontFamilyDiv'; // Set default option
        showTab('watermarkTextDiv'); // Show default tab
    };

window.showTab = showTab;

});
// Attach saveWatermarkInputs to the beforeunload event
window.addEventListener("beforeunload", (event) => {
    saveWatermarkInputs();
});

</script>

</body>
</html>
