<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard</title>
    <!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">


<link rel="stylesheet" href="../css/admin.css">

</head>
<body>



<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-dark">
    <a class="navbar-brand" href="https://shutterworx.co/">ShutterWorx </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ml-auto">
            <li class="nav-item">
                <a class="nav-link" href="../">Your Site</a>
            </li>

            <li class="nav-item">
                <a class="nav-link" href="../admin/">Home</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/media">Media</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/contact">Contact</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/design">Design</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/analytics">Analytics</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/transactions">Transactions</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../admin/settings">Settings</a>
            </li>
        </ul>
    </div>
</nav>


<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
      <li class="breadcrumb-item"><a href="../admin/">Home</a></li>
      <li class="breadcrumb-item active" aria-current="page">Welcome </li>
    </ol>
  </nav>
  


  <main id="main-content">

<!-- Login Section -->
<div id="firebaseLogin" class="container-fluid">
    <h1 class="mb-4">Login to Access Dashboard</h1>
    <button onclick="googleLogin()" class="btn btn-primary">Login with Google</button>
    <button onclick="phoneLogin()" class="btn btn-secondary">Login with Phone</button>
    <button onclick="emailLogin()" class="btn btn-info">Login with Email</button>
</div>

<!-- Dashboard Section (hidden by default) -->
<div id="dashboardContent" class="container-fluid dashboard-container">
    <h1 class="mb-4">Admin Dashboard</h1>
    
    <section>
        <div id="admin-messages" class="admin-messages-container">
            <p id="message-text" class="fade-in"></p>
            <div id="message-actions" class="message-actions"></div>
          </div>
          
    </section>

    <section>
    <!-- Quick Links Section -->
    <div class="row mb-4">
        <div class="col">
            <a href="media" class="card nav-link">
                <div class="card-body text-center">
                    <h5>Event & Photo Management</h5>
                    <p>Upload, edit, and organize events and photos.</p>
                </div>
            </a>
        </div>
        <!-- Additional quick links as in previous code... -->
    </div>
</section>

<section>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }

        #qrCanvas {
            margin-top: 20px;
            border: 1px solid #ccc;
            cursor: pointer;
            max-width: 100%;
            height: auto;
        }

        #generateBtn, #downloadBtn {
            padding: 10px 20px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }

        #generateBtn:hover, #downloadBtn:hover {
            background-color: #0056b3;
        }

        .spinner {
            display: none;
            margin-top: 20px;
            font-size: 16px;
            font-weight: bold;
            color: #007BFF;
        }

        #inputWrapper {
            margin-bottom: 20px;
        }

        input {
            padding: 8px 12px;
            font-size: 16px;
            width: 80%;
            max-width: 500px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            #inputWrapper {
                width: 90%;
                margin: auto;
            }
        }

    </style>

    <div id="inputWrapper">
        <label>QR Code Generater</label>
        <input type="text" id="qrInput" placeholder="Enter text or URL" />
        <button id="generateBtn">Generate QR Code</button>
        <button id="downloadBtn" style="display:none;">Download QR Code</button>
    </div>
    <div class="spinner" id="spinner">Generating...</div>
    <canvas id="qrCanvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.0/dist/qrious.min.js"></script>
    <script>
        // Function to sanitize and remove http:// or https://
        function sanitizeInput(input) {
            let sanitizedInput = input.trim();

            // Remove http:// or https:// if present
            sanitizedInput = sanitizedInput.replace(/^https?:\/\//i, '');

            return sanitizedInput;
        }

        // Function to generate QR Code using QRious library
        function generateQRCode(text, canvas, image = null, size = 300, level = 'H') {
            const qr = new QRious({
                element: canvas,
                value: text,
                size: size,
                level: level,
                background: '#ffffff',
                foreground: '#000000',
            });

            if (image) {
                const ctx = canvas.getContext('2d');
                const imageSize = size / 4; // Adjust size of the image in the center (25% of QR size)
                const xPos = (size - imageSize) / 2; // Center the image horizontally
                const yPos = (size - imageSize) / 2; // Center the image vertically

                // Wait for the image to load before drawing it onto the canvas
                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, xPos, yPos, imageSize, imageSize);
                };
                img.src = image; // Set the image source
            }
        }

        // Function to handle button click and QR code generation
        function handleGenerateQRCode() {
            const inputValue = qrInput.value.trim();
            if (!inputValue) {
                alert("Please enter text or a URL to generate a QR Code.");
                return;
            }

            // Sanitize the input (remove http:// or https://)
            const sanitizedInput = sanitizeInput(inputValue);

            // Show loading spinner while generating QR code
            document.getElementById("spinner").style.display = "inline-block";

            // Delay QR code generation to simulate loading
            setTimeout(() => {
                // Generate the QR code with a placeholder image in the center
                generateQRCode(sanitizedInput, qrCanvas, 'https://rawphotographysite.com/images/main.jpg'); // Example image URL

                // Hide spinner after QR code generation
                document.getElementById("spinner").style.display = "none";

                // Show the download button after QR code generation
                document.getElementById("downloadBtn").style.display = "inline-block";

                // Add click event to redirect when the canvas is clicked
                qrCanvas.onclick = function () {
                    window.location.href = sanitizedInput;
                };
            }, 500); // Simulate loading delay
        }

        // Function to download QR code as an image
        function downloadQRCode() {
            const canvas = qrCanvas;
            const imageUrl = canvas.toDataURL("image/png");

            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = 'qr_code.png';
            link.click();
        }

        // Add event listener to the buttons
        const generateBtn = document.getElementById("generateBtn");
        const qrInput = document.getElementById("qrInput");
        const qrCanvas = document.getElementById("qrCanvas");
        const downloadBtn = document.getElementById("downloadBtn");

        generateBtn.addEventListener("click", handleGenerateQRCode);
        downloadBtn.addEventListener("click", downloadQRCode);
    </script>
</section>


<section>
    <!-- Notifications & Statistics Summary -->
    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">Recent Notifications</div>
                <div class="card-body">
                    <ul id="notificationList" class="list-group"></ul>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">Statistics Summary</div>
                <div class="card-body row text-center">
                    <!-- Statistics content as in previous code... -->
                </div>
            </div>
        </div>
    </div>
</section>
</div>

</main>
<!-- Footer -->
<footer class="bg-dark text-light py-3">
  <div class="container">
      <div class="row">
          <div class="col-md-6">
              <p>&copy; 2024 <a href="https://ShutterWorx.co" class="text-light">ShutterWorx</a> All rights reserved.</p>
          </div>
          <div class="col-md-6 text-md-right">
              <ul class="list-inline">
                  <li class="list-inline-item"><a href="https://ShutterWorx.co/FAQ" class="text-light">FAQs</a></li>
                  <li class="list-inline-item"><a href="https://ShutterWorx.co/join" class="text-light">Upgrade</a></li>
                  <li class="list-inline-item"><a href="https://ShutterWorx.co/contact" class="text-light">Contact Us</a></li>
                  <li class="list-inline-item"><a href="https://ShutterWorx.co/privacy" class="text-light">Privacy Policy</a></li>
                  <li class="list-inline-item"><a href="https://ShutterWorx.co/terms" class="text-light">Terms of Service</a></li>
              </ul>
          </div>
      </div>
  </div>
</footer>


<script src="../js/admin.js" ></script>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>

<!-- Phone Login Modal (Admin UI) -->
<div id="phoneLoginModal" class="modal">
    <div class="modal-content">
        <h3>Phone Login</h3>
        <div id="recaptcha-container"></div>
        <div class="form-group">
            <label for="phoneNumber">Enter your phone number:</label>
            <input type="tel" id="phoneNumber" class="form-control" placeholder="+1xxxxxxxxxx" required>
            <small id="phoneNumberError" class="text-danger" style="display: none;">Please enter a valid phone number.</small>
        </div>
        <button id="sendVerificationCode" class="btn btn-primary" onclick="phoneLogin()">Send Verification Code</button>
        <div id="verificationCodeGroup" style="display: none;">
            <label for="verificationCode">Enter Verification Code:</label>
            <input type="text" id="verificationCode" class="form-control" placeholder="123456" required>
            <button id="verifyCode" class="btn btn-success" onclick="verifyCode()">Verify Code</button>
        </div>
        <div id="loading" style="display: none;">Please wait...</div>
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
    </div>
</div>
<!-- Firebase JS SDK and Custom Scripts -->
<script type="module">
    import {  db, doc,getDoc, query, updateDoc,
    setDoc,     signInWithPopup,
    GoogleAuthProvider,
    FacebookAuthProvider,getAuth, signInWithPhoneNumber, RecaptchaVerifier,
    OAuthProvider,arrayUnion ,
    signOut, addDoc , increment,
    onAuthStateChanged,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    where, getDocs, storage, collection, auth, analytics  } from '../js/module.js';
  
  
// Allowed emails and phone numbers
const allowedEmails = ["1988lrp@gmail.com", "amorette330@yahoo.com"];
const allowedPhoneNumbers = ["+9725977878", "+5013267622"];

// Function to update login record in the 'Logins' collection
async function updateLoginRecord(user) {
    try {
        const loginDoc = doc(collection(db, "Logins"), user.uid);

        // Fetch existing document
        const loginSnapshot = await getDoc(loginDoc);
        let existingLogins = loginSnapshot.exists() ? loginSnapshot.data().logins || [] : [];

        // Add new login record
        existingLogins.push({
            email: user.email || null,
            timestamp: new Date()
        });

        // Update the document
        await setDoc(loginDoc, {
            logins: existingLogins,
            email: user.email || null,
            phoneNumber: user.phoneNumber || null,
            lastLogin: new Date()
        }, { merge: true });

        localStorage.setItem('isLoggedIn', 'true');
        showToast('Logged in successfully!');
        console.log("Login record updated for:", user.uid);
    } catch (error) {
        console.error("Error updating login record:", error);
        showToast('Failed to update login record.');
    }
}


// Google Login function
function googleLogin() {
    const provider = new GoogleAuthProvider();
    signInWithPopup(auth, provider)
        .then((result) => {
            const user = result.user;
            const userEmail = user.email;
            if (allowedEmails.includes(userEmail)) {
                updateLoginRecord(user); // Update login record
                showDashboard();
            } else {
                alert("Access denied: Email not authorized.");
                auth.signOut();
            }
        })
        .catch((error) => console.error("Google login error:", error));
}
window.googleLogin = googleLogin;

// Phone Login function


Memory Full
You said:
make this image downloader work with no problems, make suggestion also, 
// Include JSZip for zipping files
const JSZip = window.JSZip;
const jsPDF = window.jspdf.jsPDF; // If using jsPDF for PDF creation

async function downloadFile(eventId, format) {
    try {
        console.log(Initiating free download for Event #${eventId} as ${format}.);

        // Fetch media images related to this event
        const imageData = await fetchMediaImages(eventId); // Ensure this function returns an array of image objects
        if (!imageData || imageData.length === 0) {
            showError("No media available for download.");
            return;
        }

        if (format === 'zip' || format === 'pdf') {
            // Handle ZIP or PDF generation
            await downloadAsZipOrPdf(eventId, imageData, format);
        } else {
            // Handle individual downloads for jpg/png
            let photoCountDownload = 0;
            console.log(imageData.: ${imageData});
            console.log(eventId: ${eventId});

            imageData.forEach((img, index) => {
                const fileName = Event_${eventId}_${index + 1}.${format};
                const photoUrl = img.photoUrl; // Ensure this is the correct field for the image URL
                console.log(Downloading photo: ${photoUrl});

                // Create a hidden link to initiate the download
                const link = document.createElement('a');
                link.href = photoUrl;
                link.download = eventId;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                photoCountDownload++;
            });

            showToast(Downloaded ${photoCountDownload} files for Event #${eventId} as ${format}.);
        }
    } catch (error) {
        console.error("Error during free download:", error);
        showError("An error occurred during the download. Please try again.");
    }
}

async function downloadAsZipOrPdf(eventId, imageData, format) {
    try {
        const zip = new JSZip();

        if (format === 'pdf') {
            // Create a single PDF file
            const pdf = new jsPDF();

            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const imageUrl = img.photoUrl;
                console.log(Downloading photo: ${imageUrl});

                const imgData = await fetchImageAsBase64(imageUrl);
                pdf.addImage(imgData, 'JPEG', 10, 10, 190, 140); // Adjust dimensions as needed
                if (i < imageData.length - 1) pdf.addPage();
            }

            
            const pdfBlob = pdf.output('blob');
            const pdfLink = document.createElement('a');
            pdfLink.href = URL.createObjectURL(pdfBlob);
            pdfLink.download = Event_${eventId}.pdf;
            document.body.appendChild(pdfLink);
            pdfLink.click();
            document.body.removeChild(pdfLink);

            showToast(PDF file for Event #${eventId} downloaded successfully.);
        } else if (format === 'zip') {
            // Add each image to the ZIP file
            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const response = await fetch(imageData.photoUrl, { mode: 'no-cors' });
                const blob = await response.blob();
                zip.file(Event_${eventId}_${i + 1}.jpg, blob);
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipLink = document.createElement('a');
            zipLink.href = URL.createObjectURL(zipBlob);
            zipLink.download = Event_${eventId}.zip;
            document.body.appendChild(zipLink);
            zipLink.click();
            document.body.removeChild(zipLink);

            showToast(ZIP file for Event #${eventId} downloaded successfully.);
        }
    } catch (error) {
        console.error("Error during ZIP or PDF generation:", error);
        showError("An error occurred while generating the file. Please try again.");
    }
}

async function fetchImageAsBase64(url) {
  const response = await fetch(url, { mode: 'no-cors' });
  const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}
ChatGPT said:
ChatGPT
Here are some suggestions and fixes to ensure your image downloader works smoothly:

1. Ensure fetchMediaImages Works Properly:
The function fetchMediaImages(eventId) should return an array of image objects, and the photoUrl field in each image should be valid. Ensure that this function is implemented correctly and is retrieving the media data in the expected format.

2. Handling CORS Issues:
Since you're using mode: 'no-cors' for fetch requests, it can prevent you from retrieving the response properly (especially if you're trying to get the image data as a blob). Consider either using a proxy server or ensuring the server hosting the images supports CORS for your domain.

3. Improvement in Download Logic:
Currently, your download logic for images seems to assume the photoUrl is directly accessible. If the URL is not direct or has CORS restrictions, the download may fail. You can:

Add a check for the image URL's validity before attempting the download.
Try using blob URLs to handle images fetched with the fetch() API.
4. PDF Generation:
When creating a PDF, it's important to ensure that the image is loaded completely before attempting to add it to the PDF. If you have large images, this could take some time. Consider adding a loading spinner or progress indicator.

5. Improvement in Error Handling:
The showError function should be implemented to provide feedback when there's a failure.
Similarly, the showToast function should be used to give feedback when images are downloaded successfully.
6. General Code Cleanup:
Some improvements in readability and efficiency:

Combine repeated logic where possible, such as creating the download link, to reduce redundancy.
Revised Code with Suggestions:
// Include JSZip for zipping files
const JSZip = window.JSZip;
const jsPDF = window.jspdf.jsPDF; // If using jsPDF for PDF creation

async function downloadFile(eventId, format) {
    try {
        console.log(`Initiating free download for Event #${eventId} as ${format}.`);

        // Fetch media images related to this event
        const imageData = await fetchMediaImages(eventId);
        if (!imageData || imageData.length === 0) {
            showError("No media available for download.");
            return;
        }

        if (format === 'zip' || format === 'pdf') {
            // Handle ZIP or PDF generation
            await downloadAsZipOrPdf(eventId, imageData, format);
        } else {
            // Handle individual downloads for jpg/png
            let photoCountDownload = 0;
            imageData.forEach((img, index) => {
                const fileName = `Event_${eventId}_${index + 1}.${format}`;
                const photoUrl = img.photoUrl;
                console.log(`Downloading photo: ${photoUrl}`);

                // Create a hidden link to initiate the download
                const link = document.createElement('a');
                link.href = photoUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                photoCountDownload++;
            });

            showToast(`Downloaded ${photoCountDownload} files for Event #${eventId} as ${format}.`);
        }
    } catch (error) {
        console.error("Error during free download:", error);
        showError("An error occurred during the download. Please try again.");
    }
}

async function downloadAsZipOrPdf(eventId, imageData, format) {
    try {
        const zip = new JSZip();

        if (format === 'pdf') {
            // Create a single PDF file
            const pdf = new jsPDF();

            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const imageUrl = img.photoUrl;
                console.log(`Downloading photo: ${imageUrl}`);

                const imgData = await fetchImageAsBase64(imageUrl);
                pdf.addImage(imgData, 'JPEG', 10, 10, 190, 140); // Adjust dimensions as needed
                if (i < imageData.length - 1) pdf.addPage();
            }

            const pdfBlob = pdf.output('blob');
            const pdfLink = document.createElement('a');
            pdfLink.href = URL.createObjectURL(pdfBlob);
            pdfLink.download = `Event_${eventId}.pdf`;
            document.body.appendChild(pdfLink);
            pdfLink.click();
            document.body.removeChild(pdfLink);

            showToast(`PDF file for Event #${eventId} downloaded successfully.`);
        } else if (format === 'zip') {
            // Add each image to the ZIP file
            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const photoUrl = img.photoUrl;
                console.log(`Downloading photo: ${photoUrl}`);

                const response = await fetch(photoUrl, { mode: 'cors' });  // Use 'cors' instead of 'no-cors'
                if (!response.ok) {
                    throw new Error(`Failed to fetch image ${photoUrl}`);
                }

                const blob = await response.blob();
                zip.file(`Event_${eventId}_${i + 1}.jpg`, blob);
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipLink = document.createElement('a');
            zipLink.href = URL.createObjectURL(zipBlob);
            zipLink.download = `Event_${eventId}.zip`;
            document.body.appendChild(zipLink);
            zipLink.click();
            document.body.removeChild(zipLink);

            showToast(`ZIP file for Event #${eventId} downloaded successfully.`);
        }
    } catch (error) {
        console.error("Error during ZIP or PDF generation:", error);
        showError("An error occurred while generating the file. Please try again.");
    }
}

async function fetchImageAsBase64(url) {
  const response = await fetch(url, { mode: 'cors' });  // Use 'cors' instead of 'no-cors'
  const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// Utility functions for showing notifications
function showToast(message) {
    console.log(message);  // Replace with actual toast implementation
}

function showError(message) {
    alert(message);  // Replace with more user-friendly error handling
}
Key Changes:
CORS Issue Handling: Switched from mode: 'no-cors' to mode: 'cors'. You should ensure the server hosting the images allows CORS requests.
General Improvements: Reduced redundancy in the download process.
Download File Names: Corrected the download file name to use fileName instead of eventId.
Toast and Error Handling: Added example utility functions for showToast and showError for better feedback management.
Additional Suggestions:
Progress Indicators: Consider adding a loading spinner or progress bar for large file downloads.
Error Feedback: Enhance user feedback for cases like incomplete or failed image downloads.
Caching: Implement caching for images if they are frequently downloaded to reduce redundant fetch calls.
Let me know if you need further assistance!






You said:
make the proformaic better, // Include JSZip for zipping files
const JSZip = window.JSZip;
const jsPDF = window.jspdf.jsPDF; // If using jsPDF for PDF creation

async function downloadFile(eventId, format) {
    try {
        console.log(Initiating free download for Event #${eventId} as ${format}.);

        // Fetch media images related to this event
        const imageData = await fetchMediaImages(eventId);
        if (!imageData || imageData.length === 0) {
            showError("No media available for download.");
            return;
        }

        if (format === 'zip' || format === 'pdf') {
            // Handle ZIP or PDF generation
            await downloadAsZipOrPdf(eventId, imageData, format);
        } else {
            // Handle individual downloads for jpg/png
            let photoCountDownload = 0;
            imageData.forEach((img, index) => {
                const fileName = Event_${eventId}_${index + 1}.${format};
                const photoUrl = img.photoUrl;
                console.log(Downloading photo: ${photoUrl});

                // Create a hidden link to initiate the download
                const link = document.createElement('a');
                link.href = photoUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                photoCountDownload++;
            });

            showToast(Downloaded ${photoCountDownload} files for Event #${eventId} as ${format}.);
        }
    } catch (error) {
        console.error("Error during free download:", error);
        showError("An error occurred during the download. Please try again.");
    }
}

async function downloadAsZipOrPdf(eventId, imageData, format) {
    try {
        const zip = new JSZip();

        if (format === 'pdf') {
            // Create a single PDF file
            const pdf = new jsPDF();

            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const imageUrl = img.photoUrl;
                console.log(Downloading photo: ${imageUrl});

                const imgData = await fetchImageAsBase64(imageUrl);
                pdf.addImage(imgData, 'JPEG', 10, 10, 190, 140); // Adjust dimensions as needed
                if (i < imageData.length - 1) pdf.addPage();
            }

            const pdfBlob = pdf.output('blob');
            const pdfLink = document.createElement('a');
            pdfLink.href = URL.createObjectURL(pdfBlob);
            pdfLink.download = Event_${eventId}.pdf;
            document.body.appendChild(pdfLink);
            pdfLink.click();
            document.body.removeChild(pdfLink);

            showToast(PDF file for Event #${eventId} downloaded successfully.);
        } else if (format === 'zip') {
            // Add each image to the ZIP file
            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const photoUrl = img.photoUrl;
                console.log(Downloading photo: ${photoUrl});

                const response = await fetch(photoUrl, { mode: 'cors' });  // Use 'cors' instead of 'no-cors'
                if (!response.ok) {
                    throw new Error(Failed to fetch image ${photoUrl});
                }

                const blob = await response.blob();
                zip.file(Event_${eventId}_${i + 1}.jpg, blob);
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipLink = document.createElement('a');
            zipLink.href = URL.createObjectURL(zipBlob);
            zipLink.download = Event_${eventId}.zip;
            document.body.appendChild(zipLink);
            zipLink.click();
            document.body.removeChild(zipLink);

            showToast(ZIP file for Event #${eventId} downloaded successfully.);
        }
    } catch (error) {
        console.error("Error during ZIP or PDF generation:", error);
        showError("An error occurred while generating the file. Please try again.");
    }
}

async function fetchImageAsBase64(url) {
  const response = await fetch(url, { mode: 'cors' });  // Use 'cors' instead of 'no-cors'
  const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// Utility functions for showing notifications
function showToast(message) {
    console.log(message);  // Replace with actual toast implementation
}

function showError(message) {
    alert(message);  // Replace with more user-friendly error handling
}
ChatGPT said:
ChatGPT
Your updated code is more refined with improvements like better error handling, dynamic file naming, and a proper fetch mode ('cors'). Here are some suggestions and improvements for enhancing readability, handling edge cases, and ensuring better usability:

Suggestions and Improvements:
Error Handling:

You can improve error handling by including more specific messages or custom error codes, especially for cases like a failed fetch or unsupported file format.
Handle scenarios where the file format isn't supported before attempting the download.
Asynchronous File Handling:

Ensure you handle async operations correctly, especially with large numbers of images. Right now, you handle them in a sequential manner (forEach), but using Promise.all() would make it more efficient for concurrent image downloads or PDF generation.
File Format Validation:

It's good practice to validate that the file format passed (zip, pdf, jpg, png, etc.) is supported before proceeding with downloads. This can prevent errors or unexpected behavior when an unsupported file type is passed.
Progress Feedback:

If you plan to allow large files or many images to be downloaded, consider adding a loading spinner or progress bar to indicate that the process is ongoing.
Download URL Validation:

You should ensure that photoUrl contains a valid URL before trying to download the image.
File Format Defaulting:

You can provide a default behavior if no valid format is specified (e.g., download as .jpg if no format is selected).
Here's an updated version of the code with these suggestions applied:

// Include JSZip for zipping files
const JSZip = window.JSZip;
const jsPDF = window.jspdf.jsPDF; // If using jsPDF for PDF creation

async function downloadFile(eventId, format = 'jpg') {
    try {
        console.log(`Initiating download for Event #${eventId} as ${format}.`);

        // Fetch media images related to this event
        const imageData = await fetchMediaImages(eventId);
        if (!imageData || imageData.length === 0) {
            showError("No media available for download.");
            return;
        }

        // Validate file format
        if (!['zip', 'pdf', 'jpg', 'png'].includes(format)) {
            showError(`Unsupported format: ${format}. Please choose from 'zip', 'pdf', 'jpg', 'png'.`);
            return;
        }

        if (format === 'zip' || format === 'pdf') {
            // Handle ZIP or PDF generation
            await downloadAsZipOrPdf(eventId, imageData, format);
        } else {
            // Handle individual downloads for jpg/png
            let photoCountDownload = 0;
            for (let i = 0; i < imageData.length; i++) {
                const img = imageData[i];
                const fileName = `Event_${eventId}_${i + 1}.${format}`;
                const photoUrl = img.photoUrl;
                console.log(`Downloading photo: ${photoUrl}`);

                // Validate the URL before attempting download
                if (!isValidUrl(photoUrl)) {
                    console.error(`Invalid URL: ${photoUrl}`);
                    showError(`Failed to download image #${i + 1}: Invalid URL.`);
                    continue; // Skip to the next image
                }

                // Create a hidden link to initiate the download
                const link = document.createElement('a');
                link.href = photoUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                photoCountDownload++;
            }

            showToast(`Downloaded ${photoCountDownload} files for Event #${eventId} as ${format}.`);
        }
    } catch (error) {
        console.error("Error during download:", error);
        showError("An error occurred during the download. Please try again.");
    }
}

async function downloadAsZipOrPdf(eventId, imageData, format) {
    try {
        const zip = new JSZip();

        if (format === 'pdf') {
            // Create a single PDF file
            const pdf = new jsPDF();

            // Process each image asynchronously
            const imagePromises = imageData.map(async (img, i) => {
                const imageUrl = img.photoUrl;
                console.log(`Processing photo: ${imageUrl}`);

                const imgData = await fetchImageAsBase64(imageUrl);
                pdf.addImage(imgData, 'JPEG', 10, 10, 190, 140); // Adjust dimensions as needed
                if (i < imageData.length - 1) pdf.addPage();
            });

            await Promise.all(imagePromises);  // Wait for all images to be processed

            const pdfBlob = pdf.output('blob');
            const pdfLink = document.createElement('a');
            pdfLink.href = URL.createObjectURL(pdfBlob);
            pdfLink.download = `Event_${eventId}.pdf`;
            document.body.appendChild(pdfLink);
            pdfLink.click();
            document.body.removeChild(pdfLink);

            showToast(`PDF file for Event #${eventId} downloaded successfully.`);
        } else if (format === 'zip') {
            // Add each image to the ZIP file
            const imagePromises = imageData.map(async (img, i) => {
                const photoUrl = img.photoUrl;
                console.log(`Processing photo: ${photoUrl}`);

                if (!isValidUrl(photoUrl)) {
                    console.error(`Invalid URL: ${photoUrl}`);
                    return;
                }

                const response = await fetch(photoUrl, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to fetch image ${photoUrl}`);
                }

                const blob = await response.blob();
                zip.file(`Event_${eventId}_${i + 1}.jpg`, blob);
            });

            await Promise.all(imagePromises);  // Wait for all images to be added to the zip

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipLink = document.createElement('a');
            zipLink.href = URL.createObjectURL(zipBlob);
            zipLink.download = `Event_${eventId}.zip`;
            document.body.appendChild(zipLink);
            zipLink.click();
            document.body.removeChild(zipLink);

            showToast(`ZIP file for Event #${eventId} downloaded successfully.`);
        }
    } catch (error) {
        console.error("Error during ZIP or PDF generation:", error);
        showError("An error occurred while generating the file. Please try again.");
    }
}

async function fetchImageAsBase64(url) {
    const response = await fetch(url, { mode: 'cors' });
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// Utility function to check if URL is valid
function isValidUrl(url) {
    try {
        new URL(url);  // Try to create a new URL object
        return true;
    } catch (e) {
        return false;
    }
}

// Utility functions for showing notifications
function showToast(message) {
    console.log(message);  // Replace with actual toast implementation
}

function showError(message) {
    alert(message);  // Replace with more user-friendly error handling
}
Key Changes:
File Format Validation: Ensures that the format passed is one of the valid types (zip, pdf, jpg, png).
Image Download Validation: Before downloading, checks if the image URL is valid.
Async Handling with Promise.all: Optimized asynchronous handling for image downloads and PDF/ZIP generation by processing all images concurrently using Promise.all().
Error Handling: More specific error messages, including for invalid URLs and failed image fetches.
This version should improve performance, stability, and user experience.






You said:
on the new firebase is there a way I can make sure my storage works withe the website.. Access to fetch at 'https://firebasestorage.googleapis.com/v0/b/raw-photography-12616.firebasestorage.app/o/eventPhotos%2Fji4fYjkyXABSLhJb8ugb%2F465032638_101055.jpg?alt=media&token=e8f70a2e-081b-4208-9425-08b5a613330d' from origin 'https://rawphotographysite.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
ChatGPT said:
ChatGPT
The error you're encountering is related to Cross-Origin Resource Sharing (CORS). When you're trying to access resources (like images) stored in Firebase Storage from a different domain (in this case, https://rawphotographysite.com), Firebase requires that the server (Firebase Storage) explicitly allows the origin (your website) to access the resource.

To resolve this issue, you need to set up CORS configuration on Firebase Storage to permit access from your website. Here's how you can do that:

1. Set Up CORS in Firebase Storage
Firebase Storage allows you to configure CORS through the Firebase CLI. Here’s a step-by-step guide:

Step 1: Install Firebase Tools
If you haven't installed Firebase CLI yet, do so by running:

npm install -g firebase-tools
Step 2: Initialize Firebase in Your Project
Navigate to your project folder and run:

firebase init
Make sure you enable Storage when prompted.

Step 3: Create a cors.json Configuration File
Create a file named cors.json in the root directory of your project with the following content:

[
  {
    "origin": ["https://rawphotographysite.com"],
    "method": ["GET", "HEAD"],
    "maxAgeSeconds": 3600
  }
]
This configuration tells Firebase Storage to allow cross-origin requests from your website (https://rawphotographysite.com) for GET and HEAD methods, with a max-age of 1 hour for caching.

Step 4: Apply the CORS Configuration
Once you've created the cors.json file, apply the CORS settings by running:

firebase storage:bucket --cors cors.json
This will update the CORS configuration for Firebase Storage.

Step 5: Verify the Changes
After updating the CORS configuration, try accessing the resource again from your website. The error should no longer appear if everything is configured correctly.

2. Why Not Use no-cors?
While setting the mode: 'no-cors' in the fetch request might seem like a quick solution, it’s not ideal because it only allows you to access the data in a limited way. For instance, you won't be able to get the actual image data (like the Blob or Base64 content). Therefore, it’s better to configure CORS properly so that you can interact with the full data from Firebase Storage.

3. Firebase Storage CORS Configuration Summary
origin: The allowed domains (in this case, https://rawphotographysite.com).
method: The allowed HTTP methods (GET, POST, PUT, etc.).
maxAgeSeconds: The duration in seconds that the browser should cache the preflight response.
Once you set up CORS correctly, you should no longer face the CORS error when trying to fetch files from Firebase Storage.






You said:
make a function for the images with the class downloadable, that download the src of a image when clicked n it.
ChatGPT said:
ChatGPT
Here's a simple function that will download the src of images with the class downloadable when they are clicked:

<!-- Example HTML -->
<img src="image1.jpg" class="downloadable" alt="Image 1">
<img src="image2.jpg" class="downloadable" alt="Image 2">
<img src="image3.jpg" class="downloadable" alt="Image 3">

<script>
// Function to handle image download
function setupDownloadableImages() {
    const images = document.querySelectorAll('.downloadable');

    images.forEach(image => {
        image.addEventListener('click', () => {
            const imageUrl = image.src; // Get the src of the clicked image
            const fileName = imageUrl.substring(imageUrl.lastIndexOf('/') + 1); // Extract filename

            // Create a hidden link to initiate the download
            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = fileName; // Set the file name for download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    });
}

// Call the function to set up the event listeners
setupDownloadableImages();
</script>
Explanation:
Selecting Elements:

document.querySelectorAll('.downloadable') gets all images that have the downloadable class.
Iterating over Images:

images.forEach(image => {...} loops through each downloadable image.
Event Listener:

Each image attaches a click event listener.
Inside the event handler, the src of the clicked image is stored in imageUrl.
fileName is derived from the URL to create a proper filename for the download.
A new <a> element is created with href set to imageUrl and download set to fileName.
The <a> element is appended to the document, click() is called to initiate the download, and finally, it's removed from the document.
This setup will work for all images with the class downloadable on your page.


1/2






You said:
assert.ts:161 Uncaught FirebaseError: Firebase: Error (auth/argument-error).
    at B (assert.ts:161:7)
    at K (assert.ts:264:19)
    at new Jn (recaptcha_verifier.ts:109:10)
    at phoneLogin (index:397:25)
    at HTMLButtonElement.onclick (index:71:62) // Phone Login function
function phoneLogin() {
    const auth = getAuth(); // Get Firebase Auth instance
    const phoneNumber = prompt("Enter your phone number with country code (e.g., +1xxxxxxxxxx):");

    // Create reCAPTCHA verifier
    const appVerifier = new RecaptchaVerifier("recaptcha-container", {
        size: "invisible",
        callback: (response) => { /* reCAPTCHA solved - allow signInWithPhoneNumber. */ },
        "expired-callback": () => alert("reCAPTCHA expired, please try again.")
    }, auth);

    appVerifier.render();

    // Start phone number sign-in
    signInWithPhoneNumber(auth, phoneNumber, appVerifier)
        .then((confirmationResult) => {
            const verificationCode = prompt("Enter the verification code sent to your phone:");
            return confirmationResult.confirm(verificationCode);
        })
        .then((result) => {
            const user = result.user;
            if (allowedPhoneNumbers.includes(user.phoneNumber)) {
                updateLoginRecord(user); // Update login record
                showDashboard();
            } else {
                alert("Access denied: Phone number not authorized.");
                auth.signOut();
            }
        })
        .catch((error) => {
            console.error("Phone login error:", error);
            alert("Error during phone login: " + error.message);
        });
}

window.phoneLogin = phoneLogin;
Make the  admin UI pop up for the phone login, format the phone number, and make everything the best you can. pro level/

3/3

ChatGPT said:
ChatGPT
To improve your phone login function for a pro-level experience, let's break down the improvements into several parts:

UI Pop-up for Phone Login:

Use a modal or dialog box to display the phone login form, improving the user interface experience.
Format the phone number to ensure the input is in the correct format.
Display relevant messages and loading states to keep the user informed.
Phone Number Validation:

Use a phone number input mask to format the number (including the country code).
Validate the phone number to ensure it matches expected formats before attempting to send the OTP.
Enhanced Error Handling and UI Feedback:

Provide more user-friendly feedback on error conditions.
Make the reCAPTCHA process more visible if needed.
Handle expired reCAPTCHA in a more user-friendly manner.
Here's a refactored version of your phone login function with these improvements:

<!-- Phone Login Modal (Admin UI) -->
<div id="phoneLoginModal" class="modal">
    <div class="modal-content">
        <h3>Phone Login</h3>
        <div id="recaptcha-container"></div>
        <div class="form-group">
            <label for="phoneNumber">Enter your phone number:</label>
            <input type="tel" id="phoneNumber" class="form-control" placeholder="+1xxxxxxxxxx" required>
            <small id="phoneNumberError" class="text-danger" style="display: none;">Please enter a valid phone number.</small>
        </div>
        <button id="sendVerificationCode" class="btn btn-primary" onclick="phoneLogin()">Send Verification Code</button>
        <div id="verificationCodeGroup" style="display: none;">
            <label for="verificationCode">Enter Verification Code:</label>
            <input type="text" id="verificationCode" class="form-control" placeholder="123456" required>
            <button id="verifyCode" class="btn btn-success" onclick="verifyCode()">Verify Code</button>
        </div>
        <div id="loading" style="display: none;">Please wait...</div>
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
    </div>
</div>

<script>
// Improved phone login with modal and phone number formatting
const allowedPhoneNumbers = ['+1xxxxxxxxxx']; // Example allowed phone numbers for admin
let confirmationResult = null; // Store the confirmation result

// Initialize Firebase Auth and reCAPTCHA
const auth = getAuth();
const recaptchaContainer = document.getElementById("recaptcha-container");

function openModal() {
    const modal = document.getElementById("phoneLoginModal");
    modal.style.display = "block";
}

function closeModal() {
    const modal = document.getElementById("phoneLoginModal");
    modal.style.display = "none";
}

// Phone login function
function phoneLogin() {
    const phoneNumber = document.getElementById("phoneNumber").value.trim();
    const phoneNumberError = document.getElementById("phoneNumberError");
    
    // Validate phone number format
    if (!validatePhoneNumber(phoneNumber)) {
        phoneNumberError.style.display = "block";
        return;
    }
    phoneNumberError.style.display = "none";

    showLoading(true);
    
    // Create reCAPTCHA verifier
    const appVerifier = new RecaptchaVerifier("recaptcha-container", {
        size: "invisible",
        callback: (response) => { /* reCAPTCHA solved - allow signInWithPhoneNumber. */ },
        expiredCallback: () => alert("reCAPTCHA expired, please try again.")
    }, auth);
    
    appVerifier.render().then(() => {
        // Start phone number sign-in
        signInWithPhoneNumber(auth, phoneNumber, appVerifier)
            .then((result) => {
                confirmationResult = result;
                document.getElementById("verificationCodeGroup").style.display = "block";
                document.getElementById("sendVerificationCode").style.display = "none";
                showLoading(false);
            })
            .catch((error) => {
                console.error("Phone login error:", error);
                alert("Error during phone login: " + error.message);
                showLoading(false);
            });
    });
}

// Verify the code
function verifyCode() {
    const verificationCode = document.getElementById("verificationCode").value.trim();

    showLoading(true);
    confirmationResult.confirm(verificationCode)
        .then((result) => {
            const user = result.user;
            if (allowedPhoneNumbers.includes(user.phoneNumber)) {
                updateLoginRecord(user); // Update login record
                showDashboard();
                closeModal();
            } else {
                alert("Access denied: Phone number not authorized.");
                auth.signOut();
                showLoading(false);
            }
        })
        .catch((error) => {
            console.error("Error verifying code:", error);
            alert("Verification failed: " + error.message);
            showLoading(false);
        });
}

// Phone number validation using regex for proper format (e.g., +1xxxxxxxxxx)
function validatePhoneNumber(phoneNumber) {
    const phoneRegex = /^\+\d{1,3}\d{1,14}$/; // Simple regex for phone number validation
    return phoneRegex.test(phoneNumber);
}

// Show loading state
function showLoading(isLoading) {
    const loadingElement = document.getElementById("loading");
    const sendVerificationCodeBtn = document.getElementById("sendVerificationCode");
    const verifyCodeBtn = document.getElementById("verifyCode");

    if (isLoading) {
        loadingElement.style.display = "inline-block";
        sendVerificationCodeBtn.disabled = true;
        verifyCodeBtn.disabled = true;
    } else {
        loadingElement.style.display = "none";
        sendVerificationCodeBtn.disabled = false;
        verifyCodeBtn.disabled = false;
    }
}

// Initialize the modal on page load
document.addEventListener('DOMContentLoaded', () => {
    openModal(); // Auto-open the modal (remove this if you want a button to trigger it)
});


window.phoneLogin = phoneLogin;

// Show the dashboard content
function showDashboard() {
    document.getElementById("firebaseLogin").style.display = "none";
    document.getElementById("dashboardContent").style.display = "block";
}








/*

// Fetch notifications
// Listen for real-time updates in the "Notifications" collection
onSnapshot(collection(db, "Notifications"), (snapshot) => {
    const notificationList = document.getElementById("notificationList");
    notificationList.innerHTML = ""; // Clear existing notifications

    snapshot.forEach((doc) => {
        const notification = doc.data().message;
        const listItem = document.createElement("li");
        listItem.className = "list-group-item";
        listItem.textContent = notification;
        notificationList.appendChild(listItem);
    });
});

*/
</script>

</body>
</html>
